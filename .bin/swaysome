#!/usr/bin/env bash

# Get focused output name
monitor=$(swaymsg -t get_workspaces | jq -r '.[] | select(.focused).output')
log_path=/tmp/"$monitor"_log

# Define workspace mappings
declare -A workspace_secondary=(
  [w]="1"
  [g]="2"
  [a]="3"
)

declare -A workspace_primary=(
  [w]="4"
  [g]="5"
  [a]="6"
)

# Helper to get workspace based on monitor
get_workspace() {
  local side=$1 # primary or secondary
  local key=$2
  if [[ $side == "primary" ]]; then
    echo "${workspace_primary[$key]}"
  else
    echo "${workspace_secondary[$key]}"
  fi
}

# Define your primary output name (you can customize this)
PRIMARY_OUTPUT="HDMI-A-2" # Change this according to `swaymsg -t get_outputs`

# Determine current/target side
if [[ "$monitor" == "$PRIMARY_OUTPUT" ]]; then
  current_side="primary"
  opposite_side="secondary"
else
  current_side="secondary"
  opposite_side="primary"
fi

# register last visited workspace for current monitor
last_workspace() {
  if [ "$(wc -l <"$log_path" 2>/dev/null || echo 0)" -lt 2 ]; then
    echo "$1" >>"$log_path"
  else
    tail -n 1 "$log_path" >"$log_path.tmp"
    echo "$1" >>"$log_path.tmp"
    mv "$log_path.tmp" "$log_path"
  fi
}

back_and_forth() {
  current_wks=$(swaymsg -t get_workspaces | jq -r '.[] | select(.focused).name')
  wk1=$(awk 'NR==1' "$log_path")
  wk2=$(awk 'NR==2' "$log_path")

  if [[ "$current_wks" != "$wk1" ]]; then
    echo "moving to $wk1"
    swaymsg workspace "$wk1"
  else
    echo "moving to $wk2"
    swaymsg workspace "$wk2"
  fi
}

# Main logic
case "$1" in
move)
  wks=$(get_workspace "$current_side" "$2")
  swaymsg move container to workspace "$wks"
  ;;
move_in)
  wks=$(get_workspace "$opposite_side" "$2")
  swaymsg move container to workspace "$wks"
  ;;
back)
  back_and_forth
  ;;
*)
  wks=$(get_workspace "$current_side" "$1")
  current_wks=$(swaymsg -t get_workspaces | jq -r '.[] | select(.focused).name')
  if [[ "$current_wks" != "$wks" ]]; then
    swaymsg workspace "$wks"
    last_workspace "$wks"
  fi
  ;;
esac
